#include "stdafx.h"
#include <assert.h>
#include <math.h>

#include <GL/glut.h>

int g_screenWidth = 0;
int g_screenHeight = 0;

// velocity generated by each rule
GLfloat v_r1[3];
GLfloat v_r2[3];
GLfloat v_r3[3];
GLfloat v_r4[3];

// boids velocity and postion
GLfloat velocity_boids[20][3] = {};
GLfloat position_boids[20][3] = {};

static int points = 0;
static int number_point = 5; 
static GLfloat t = 0;
GLfloat timeIncrease = 0.1;

static int number_boids = 20;

GLfloat boidsM[20][16];

static GLfloat M[16];

static GLfloat leaderM[16];

GLfloat iniLoc[20][3] = { { -3.0f, 7.0f, -5.6f },
							{ 9.0f, 8.5f, -4.0f },
							{ 4.0f, 7.2f, -5.7f },
							{ -4.5f, 6.8f, -5.8f },
							{ 3.0f, 8.6f, -5.0f },
							{ 5.0f, 9.8f, -4.9f },
							{ -4.0f, 9.0f, -4.9f },
							{ 4.0f, 12.0f, -4.5f },
							{ 0.0f, 8.2f, -5.0f },
							{ 1.0f, 7.6f, -4.5f },
							{ -2.0f, 8.0f, -4.3f },
							{ 10.0f, 9.5f, -3.9f },
							{ 5.0f, 8.2f, -4.2f },
							{ -3.5f, 7.8f, -4.1f },
							{ 4.0f, 9.6f, -4.9f },
							{ 6.0f, 10.8f, -4.8f },
							{ -3.0f, 10.0f, -4.8f },
							{ 5.0f, 13.0f, -4.4f },
							{ 1.0f, 9.2f, -4.9f },
							{ 2.0f, 8.6f, -4.4f } };

// 7 Pionts for the leading boid in Quternion�� the first 4 numbers represent w, x, y, z in quaternion, and the rest 3 numbers represent the position x,y,z in world Cartisian System
static GLfloat point_quat[7][7] = { { 1, 0, 0, 0, 8, 2, -20 },   
											{ 0, 1, 0, 0, -8, -2, -20 },  
											{ 0, 0, 1, 0, -5, -6, -10 },  
											{ 0, 0, 0, 1, 5, -8, -10 },
											{ 0, 0, 1, 0, 3, -10, -5 },
											{ 0, 1, 0, 0, -3, -14, -5 },
											{ 1, 0, 0, 0, 1, -18, -3 } };

// The Catmul-Rom Spline M Marix
static GLfloat CRSplineM[16] = { -0.5f, 1.0f, -0.5f, 0.0f,	
									1.5f, -2.5f, 0.0f, 1.0f,
									-1.5f, 2.0f, 0.5f, 0.0f,
									0.5f, -0.5f, 0.0f, 0.0f };

// The B Spline M Marix
static GLfloat BSplineM[16] = { -1.0f / 6.0f, 3.0f / 6.0f, -3.0f / 6.0f, 1.0f / 6.0f, 
								3.0f / 6.0f, -6.0f / 6.0f, 0.0f / 6.0f, 4.0f / 6.0f,
								-3.0f / 6.0f, 3.0f / 6.0f, 3.0f / 6.0f, 1.0f / 6.0f,
								1.0f / 6.0f, 0.0f / 6.0f, 0.0f / 6.0f, 0.0f / 6.0f };

// initialate function of different rules
void r1(int index);
void r2(int index);
void r3(int index);
void r4(int index);

// Matrix Initialization: set up boidsM matrix and position_boids matrix by read in the original position of all the boids
void init()
{
	for (int j = 0; j < number_boids; j++) {
		boidsM[j][0] = 1.0f;
		boidsM[j][5] = 1.0f;
		boidsM[j][10] = 1.0f;
		for (int i = 0; i < 3; i++) {
			boidsM[j][12 + i] = iniLoc[j][i];
			position_boids[j][i] = boidsM[j][12 + i];
		}
		boidsM[j][15] = 1.0f;
	}
}

//Q(t) = T*M*G
GLfloat funcQT(GLfloat T[4], GLfloat MS[16], GLfloat G[4])
{
	GLfloat B[4] = { 0 };
	B[0] = T[0] * MS[0] + T[1] * MS[1] + T[2] * MS[2] + T[3] * MS[3];	
	B[1] = T[0] * MS[4] + T[1] * MS[5] + T[2] * MS[6] + T[3] * MS[7];	
	B[2] = T[0] * MS[8] + T[1] * MS[9] + T[2] * MS[10] + T[3] * MS[11]; 
	B[3] = T[0] * MS[12] + T[1] * MS[13] + T[2] * MS[14] + T[3] * MS[15];

	GLfloat Qt = B[0] * G[0] + B[1] * G[1] + B[2] * G[2] + B[3] * G[3];

	return Qt;
}

// Vector Normalization 
void quatToVect(GLfloat N_tempV[3])
{
	GLfloat sqQuat = 0;
	for (int i = 0; i < 3; ++i)
	{
		sqQuat += N_tempV[i] * N_tempV[i];
	}
	if (sqQuat != 0)
	{
		GLfloat baseQuat = sqrt(sqQuat);
		for (int i = 0; i < 3; ++i)
		{
			N_tempV[i] = N_tempV[i] / sqQuat;
		}
	}
}

// Quaternion to Rotation Matrix
void QuatToRot(GLfloat Q_tempM[7], GLfloat R[16])
{
	GLfloat w = Q_tempM[0];
	GLfloat x = Q_tempM[1];
	GLfloat y = Q_tempM[2];
	GLfloat z = Q_tempM[3];
	R[0] = 1.0f - 2.0f * y * y - 2.0f * z * z;
	R[1] = 2.0f * x * y + 2.0f * w * z;        
	R[2] = 2.0f * x * z - 2.0f * w * y;		   
	R[3] = 0.0f;					   
	R[4] = 2.0f * x * y - 2.0f * w * z;
	R[5] = 1.0f - 2.0f * x * x - 2.0f * z * z;
	R[6] = 2.0f * y * z + 2.0f * w * x;		  
	R[7] = 0.0f;					   
	R[8] = 2.0f * x * z + 2.0f * w * y;
	R[9] = 2.0f * y * z - 2.0f * w * x;
	R[10] = 1.0f - 2.0f * x * x - 2.0f * y * y;
	R[11] = 0.0f;					   
	R[12] = Q_tempM[4];				   
	R[13] = Q_tempM[5];			       
	R[14] = Q_tempM[6];			       
	R[15] = 1.0f;					   
}

// Quaternion Interpolating Function 
void q_interpolate(GLfloat p_quaternion[7][7], GLfloat SplineM[16])
{
	GLfloat TMatrix_q[4] = { t * t * t, t * t, t, 1 };

	GLfloat tempM[7];


	for (int i = 0; i < 7; i++)
	{
		GLfloat GMatrix_q[4] = { p_quaternion[points][i],
			p_quaternion[(points + 1) % number_point][i],
			p_quaternion[(points + 2) % number_point][i],
			p_quaternion[(points + 3) % number_point][i] };

		tempM[i] = funcQT(TMatrix_q, SplineM, GMatrix_q);
	}

	quatToVect(tempM);
	QuatToRot(tempM, leaderM);
}

// Distance: Calculate the distances between two balls
GLfloat Distance(GLfloat TempV1[3], GLfloat TempV2[3]) {

	GLfloat Distance = sqrt((TempV1[0] - TempV2[0]) * (TempV1[0] - TempV2[0]) + (TempV1[1] - TempV2[1]) * (TempV1[1] - TempV2[1]) + (TempV1[2] - TempV2[2]) * (TempV1[2] - TempV2[2]));
	return Distance;

}
// movBoids : generate the movement of boids
//			   adding the velocity generated by rules
//             calculating the position of boids
void movBoids()
{
	GLfloat v1[3];
	GLfloat v2[3];
	GLfloat v3[3];
	GLfloat v4[3];

	for (int i = 0; i < number_boids; i++)
	{
		r1(i);
		for (int j = 0; j < 3; j++)
		{
			v1[j] = v_r1[j];
		}
		r2(i);
		for (int j = 0; j < 3; j++)
		{
			v2[j] = v_r2[j];
		}
		r3(i);
		for (int j = 0; j < 3; j++)
		{
			v3[j] = v_r3[j];
		}
		r4(i);
		for (int j = 0; j < 3; j++)
		{
			v4[j] = v_r4[j];
		}

		for (int j = 0; j < 3; j++)
		{
			velocity_boids[i][j] = velocity_boids[i][j] + v1[j] + v2[j] + v3[j] + v4[j];
			position_boids[i][j] = position_boids[i][j] + velocity_boids[i][j] * 0.15;
			boidsM[i][12 + j] = position_boids[i][j];
		}
	}
}

// Rule 1 : following - boids following the leading boid
void r1(int index)
{
	for (int i = 0; i < 3; i++)
	{
		v_r1[i] = (leaderM[12 + i] - boidsM[index][12 + i]) / 3000;
	}
}
// Rule 2 : together - a boid stays close with the center of rest boids
void r2(int index)
{

	GLfloat all[3] = {};
	GLfloat center[3] = {};
	for (int i = 0; i < number_boids; i++)
	{
		all[0] += boidsM[i][12];
		all[1] += boidsM[i][13];
		all[2] += boidsM[i][14];
		for (int j = 0; j < 3; ++j)
		{
			center[j] = (all[j] - boidsM[index][12 + j]) / (number_boids - 1);
		}
	}

	for (int i = 0; i < 3; i++)
	{
		v_r2[i] = (center[i] - boidsM[index][12 + i]) / 2000;
	}
}

// Rule 3 : No collision - a boid stays a small distance away with the other boids
void r3(int index)
{
	for (int i = 0; i < number_boids; i++)
	{
		if (i != index)
		{
			if (Distance(position_boids[index], position_boids[i]) < 4)
			{
				for (int j = 0; j < 3; j++)
				{
					v_r3[j] = (v_r2[j] - (position_boids[i][j] - position_boids[index][j])) / 2000;
				}
			}
		}
	}
}
// Rule 4 : same speed - a boid match its velocity with the rest boids
void r4(int index)
{

	GLfloat all[3] = {};
	GLfloat average[3] = {};
	for (int i = 0; i < number_boids; i++)
	{
		for (int j = 0; j < 3; ++j)
		{

			all[j] += velocity_boids[i][j];
			average[j] = (all[j] - velocity_boids[index][j]) / (number_boids - 1);
		}
	}

	for (int i = 0; i < 3; i++)
	{
		v_r4[i] = (average[i] - velocity_boids[index][i]) / 2000;
	}
}


// display a individual boid
void indi(int index)
{
	glPushMatrix();
	for (int j = 0; j < 16; j++)
	{
		M[j] = boidsM[index][j];
	}
	glMultMatrixf(M);
	glutSolidSphere(0.3, 20, 20);
	glPopMatrix();
}

// display the leading boid
void lead()
{
	glPushMatrix();
	q_interpolate(point_quat, BSplineM);
	glMultMatrixf(leaderM);
	//glutSolidDodecahedron();
	glutSolidIcosahedron();
	glPopMatrix();
}

// display the leading boid and the following boids
void animBoid()
{
	lead();
	movBoids();
	for (int i = 0; i < number_boids; i++)
	{
		indi(i);
	}
}


void timer(int value) {
	glutPostRedisplay();

	// Set time increase by 0.01
	t = t + 0.01;
	if (t >= 1)
	{
		t = 0;
		if (points < number_point - 1)
		{
			points++;
		}
		else
		{
			points = 0;
		}
	}
	glutTimerFunc(16, timer, 0);
}

void render(void) {
	glClearColor(0.0, 0.0, 0.0, 1.0);
	glClearDepth(1.0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glEnable(GL_DEPTH_TEST);
	glShadeModel(GL_SMOOTH);

	// enable lighting
	glEnable(GL_LIGHTING);
	glEnable(GL_LIGHT0);

	// light source attributes
	GLfloat LightAmbient[] = { 0.5f, 0.5f, 0.5f, 1.0f };
	GLfloat LightDiffuse[] = { 0.4f, 0.4f, 0.4f, 1.0f };
	GLfloat LightSpecular[] = { 0.5f, 0.5f, 0.5f, 1.0f };
	GLfloat LightPosition[] = { 5.0f, 5.0f, 5.0f, 1.0f };

	glLightfv(GL_LIGHT0, GL_AMBIENT, LightAmbient);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, LightDiffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, LightSpecular);
	glLightfv(GL_LIGHT0, GL_POSITION, LightPosition);

	// surface material attributes
	GLfloat material_Ka[] = { 1.0f, 1.0f, 0.0f, 1.0f };
	GLfloat material_Kd[] = { 0.43f, 0.47f, 0.54f, 1.0f };
	GLfloat material_Ks[] = { 0.33f, 0.33f, 0.52f, 1.0f };
	GLfloat material_Ke[] = { 0.1f, 0.0f, 0.1f, 1.0f };
	GLfloat material_Se = 10;

	glMaterialfv(GL_FRONT, GL_AMBIENT, material_Ka);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, material_Kd);
	glMaterialfv(GL_FRONT, GL_SPECULAR, material_Ks);
	glMaterialfv(GL_FRONT, GL_EMISSION, material_Ke);
	glMaterialf(GL_FRONT, GL_SHININESS, material_Se);


	// modelview matrix
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(0, 15.0, 15.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);

	// animation	
	animBoid();

	// disable lighting
	glDisable(GL_LIGHT0);
	glDisable(GL_LIGHTING);

	// swap back and front buffers
	glutSwapBuffers();
}

// keyboard input
void keyboard(unsigned char key, int x, int y) {}

// reshape : update viewport and projection matrix when the window is resized
void reshape(int w, int h) {
	// screen size
	g_screenWidth = w;
	g_screenHeight = h;

	// viewport
	glViewport(0, 0, (GLsizei)w, (GLsizei)h);

	// projection matrix
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(65.0, (GLfloat)w / (GLfloat)h, 1.0, 50.0);
}
// main
int main(int argc, char** argv) {
	// create opengL window
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
	glutInitWindowSize(800, 600);
	glutInitWindowPosition(100, 100);
	glutCreateWindow("Lab 4");

	// user initialization
	init();

	// set callback functions
	glutDisplayFunc(render);
	glutReshapeFunc(reshape);
	glutKeyboardFunc(keyboard);
	glutTimerFunc(16, timer, 0);

	// main loop
	glutMainLoop();

	return 0;
}
